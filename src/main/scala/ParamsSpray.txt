/* Unfinished. This is a hacked-together piece of crap, with simplified shits. I'm saving it for now.
It uses the Spray library, and ideally I want to use this library to write and read JSON files with polymorphic types.
It does not work.
To Do!
*/
package Chisel

import Node._

import scala.collection.mutable.HashMap
import scala.collection.mutable.ArrayBuffer
import scala.io.Source
import java.io._

// spray imports for JSON parsing library
import spray.json._
import DefaultJsonProtocol._

abstract class Param[+T] {
  def value: T

  def register(comp: Module, pname: String) = {
    Params.register(comp, pname, this).asInstanceOf[T]
  }
}

case class ValueParam(override val value: Int) extends Param[Int]
case class RangeParam(override val value: Int, min: Int, max: Int, step: Int = 1, log: Boolean = false) extends Param[Int]
case class EnumParam(override val value: String, values: List[String]) extends Param[String]

object MyJsonProtocol extends DefaultJsonProtocol{
  implicit val valueFmt = jsonFormat1(ValueParam)
  implicit val rangeFmt = jsonFormat5(RangeParam)
  //implicit val enumFmt = jsonFormat3(EnumParam)
}

object Params {
  import MyJsonProtocol._
  type PSpace = HashMap[String,HashMap[String,Param[Any]]]
  type RSpace = HashMap[String,HashMap[String,RangeParam]]
  type VSpace = HashMap[String,HashMap[String,ValueParam]]
  //type DSpace = Seq[Param[Any]]
  //type DSpace = Tuple2[Param[Any],Param[Any]]
  //type DSpace = Map[String,Map[String,String]]
  //type DSpace = Param[Any],Param[Any]]
  //type DSpace = Param[Any]
  type DSpace = RangeParam
  //val dspace: DSpace = List(new RangeParam(1,1,1), new ValueParam(10))
  //val dspace: DSpace = (new RangeParam(1,1,1), new ValueParam(1))
  //val dspace: DSpace = new RangeParam(1,1,1)
  val dspace = new RangeParam(1,1,1)
  val rspace = Map("Theta" -> Map("W" -> new RangeParam(1,1,1)))
  var tspace = new ValueParam(1)
  //val dspace: DSpace = Map("one" -> Map("a" -> "A"), "two" -> Map("b" -> "B"))

  //dspace += new RangeParam(1,1,1)

  var space = new PSpace
  var vspace = new VSpace

  var buildingSpace = true

  def register(comp: Module, pname: String, p: Param[Any]) = {
    val cname = comp.getClass.getName
    if(buildingSpace) {
      // TODO: error on duplicate key
      if(!space.contains(cname)) {
        space(cname) = new HashMap[String,Param[Any]]
      }
      space(cname)(pname) = p
      p.value
    } else {
      // TODO: error on key not found
      vspace(cname)(pname).value
    }
  }
  
  def load(filename: String) = {
    buildingSpace = false
    val json = io.Source.fromFile(filename).mkString
    //vspace = deserializeCustom(json)
    tspace = json.asJson.convertTo[ValueParam]
  }

  def dump(filename: String) = {
    //val json = dspace.toJson
    val json = rspace.toJson
    val writer = new PrintWriter(new File(filename))
    writer.write(json.prettyPrint)
    writer.close()
    println("Dumping to " + filename + ":\n" + json.prettyPrint)
  }
  
//  def deserializeCustom(json: String) {
    
}

/* Polymorphic Example 
case class Credentials(user:String, password:String)
abstract class Provider
case class Ec2Provider(endpoint:String, creds:Credentials) extends Provider
case class OpenstackProvider(creds:Credentials) extends Provider
case class Infrastructure(name:String, provider:Provider)

object MyJsonProtocol extends DefaultJsonProtocol{
  implicit object ProviderJsonFormat extends RootJsonFormat[Provider]{
    def write(p:Provider) = p match{
      case ec2:Ec2Provider => ec2.toJson
      case os:OpenstackProvider => os.toJson
    }

    def read(value:JsValue) = value match{
      case obj:JsObject if (obj.fields.size == 2) => value.convertTo[Ec2Provider]
      case obj:JsObject => value.convertTo[OpenstackProvider]
    }
  }

  implicit val credFmt = jsonFormat2(Credentials)
  implicit val ec2Fmt = jsonFormat2(Ec2Provider)
  implicit val openStackFmt = jsonFormat1(OpenstackProvider)
  implicit val infraFmt = jsonFormat2(Infrastructure)
}

object PolyTest {
  import MyJsonProtocol._

  def main(args: Array[String]) {
    val infra = List(
    
    Infrastructure("ec2", Ec2Provider("foo", Credentials("me", "pass"))),
    Infrastructure("openstack", OpenstackProvider(Credentials("me2", "pass2")))
    )
    val json = infra.toJson.toString
    val infra2 = JsonParser(json).convertTo[List[Infrastructure]]
    println(infra == infra2)
  }
}

 -- end example */
//object JacksonWrapper {
//  //type DSpace = Seq[Param[Any]]
//  type DSpace = Tuple2[Param[Any],Param[Any]]
//  //type DSpace = Param[Any]
//  val mapper = new ObjectMapper()// with ScalaObjectMapper
//  mapper.enableDefaultTyping()
//  //mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
//  mapper.registerModule(DefaultScalaModule)
//  //mapper.setVisibility(JsonMethod.FIELD,Visibility.ANY)
//
//  def serialize(value: Any): String = {
//    val writer = new StringWriter()
//    mapper.writeValue(writer, value)
//    writer.toString
//  }
//
//  def deserialize[T: Manifest](value: String) : T = // DSpace =
//  //def deserialize[T: Manifest](value: String) : DSpace =
//    //mapper.readValue(value, classOf[DSpace])//typeReference[T])
//    mapper.readValue(value, typeReference[T])
//
//  private [this] def typeReference[T: Manifest] = new TypeReference[T] {
//    override def getType = typeFromManifest(manifest[T])
//  }
//
//  private [this] def typeFromManifest(m: Manifest[_]): Type = {
//    if (m.typeArguments.isEmpty) { m.runtimeClass }
//    else new ParameterizedType {
//      def getRawType = m.runtimeClass
//      def getActualTypeArguments = m.typeArguments.map(typeFromManifest).toArray
//      def getOwnerType = null
//    }
//  }
//}
